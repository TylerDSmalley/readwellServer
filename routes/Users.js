const express = require("express");
const router = express.Router();
const { Users } = require("../models");
const bcrypt = require("bcrypt");
const { sign } = require('jsonwebtoken');
const { validateToken } = require("../middlewares/AuthMiddleware");

//USER ROUTES-------------------------
router.post("/", async (req, res) => {
    const { firstName, lastName, email, password, isLocal } = req.body;
    bcrypt.hash(password, 10).then((hash) => {
        Users.create({
            firstName: firstName,
            lastName: lastName,
            email: email,
            password: hash,
            isLocal: isLocal,
        });
        res.json("USER CREATED");
        const sgMail = require('@sendgrid/mail')
        sgMail.setApiKey(process.env.SENDGRIDKEY)
        const msg = {
            to: req.body.email, // Change to your recipient
            from: 'itemsfsd01@gmail.com', // Change to your verified sender
            templateId: 'd-0aaf5f285705465f94305c9cf21a8f9f',
            dynamicTemplateData: {
                subject: 'Welcome to ReadWell',
                firstName: req.body.firstName
            }
        };
        sgMail
            .send(msg)
            .then(() => {
                console.log('Email sent')
            })
            .catch((error) => {
                console.error(error)
            })
    });
});

router.post("/login", async (req, res) => {
    if (req.body.firstName) {
        let email = req.body.email;
        const foundUser = await Users.findOne({ where: { email: email } });

        if (!foundUser) {

            const newUser = await Users.create({
                firstName: req.body.firstName,
                lastName: req.body.lastName,
                email: req.body.email,
                password: "",
                isLocal: "no",
            })
        } else {
            const currUser = await Users.update({
                firstName: req.body.firstName,
                lastName: req.body.lastName
            },
                {
                    where:
                        { email: email }
                })
        }

        const user = await Users.findOne({ where: { email: email } });
        const accessToken = sign(
            { email: email, id: user.id, role: user.role },
            "importantsecret"
        ); //should use autogenerated passkey for security
        res.json({ token: accessToken, email: email, id: user.id });

    } else {
        const { email, password } = req.body;

        const user = await Users.findOne({ where: { email: email } });

        if (!user) res.json({ error: "User Doesn't Exist" });

        bcrypt.compare(password, user.password).then((match) => {
            if (!match) {
                res.json({ error: "Wrong email And Password Combination" });
                return;
            }

            const accessToken = sign(
                { email: user.email, id: user.id },
                "importantsecret"
            ); //should use autogenerated passkey for security
            res.json({ token: accessToken, email: email, id: user.id });
        });
    }
});

router.get("/auth", validateToken, (req, res) => {
    res.json(req.user);
});

router.put("/changepassword", validateToken, async (req, res) => {
    const { oldPassword, newPassword } = req.body;
    const user = await Users.findOne({ where: { email: req.user.email } });

    bcrypt.compare(oldPassword, user.password).then(async (match) => {
        if (!match) res.json({ error: "Wrong Password Entered!" });

        bcrypt.hash(newPassword, 10).then((hash) => {
            Users.update(
                { password: hash },
                { where: { email: req.user.email } }
            );
            res.json("SUCCESS");
        });
    });
});

router.put("/userupdate", async (req, res) => {
    await Users.update({ firstName: req.body.firstName, lastName: req.body.lastName, email: req.body.email }, { where: { id: req.body.id } });
    res.json(req.body);
});

router.delete("/:userId", validateToken, async (req, res) => {
    const userId = req.params.userId;

    await Users.destroy({
        where: {
            id: userId,
        },
    });
    res.json("USER DELETED");
});

module.exports = router;